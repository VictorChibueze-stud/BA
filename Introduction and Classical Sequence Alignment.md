**1. Short Historical Information**

*   **Genes:**  Long ago, people did experiments (like Gregor Mendel) that showed that "things" we call genes determine how we look and function.
*   **DNA:**  A chemical called deoxy-ribonucleic acid (DNA) was found. It's what holds the instructions for building a living thing.
*   **Inheritance:** DNA is in charge of passing on traits from parents to children.
*   **Building Blocks:** DNA has a sugar called deoxyribose. RNA uses a similar sugar called ribose. DNA and RNA are called "nucleic acids."
*  **DNA Structure** Scientists (Watson and Crick) figured out that DNA has a spiral shape, like a twisted ladder, and figured out how it makes copies of itself.
* **The human genome** Researchers figured out the sequence of all DNA that makes a human, and this paved the way for a lot of new techniques, like next-generation sequencing (using machines to read DNA quickly) and deep learning (using computers to find patterns in data).

**2. Base Pairs and the DNA**

*   **DNA's Building Blocks:** DNA is made of smaller pieces called nucleotides.
*   **Nitrogen Base:** Nucleotides have a part called a nitrogen base. It's like a chemical flag and the different bases are called adenine, guanine, cytosine and thymine.
*   **Parts of Nucleotide:** Each nucleotide has a phosphate group, a sugar (deoxyribose), and one of the four nitrogen bases.
*   **Pairing:** The bases pair up in a special way, always: guanine (G) with cytosine (C), and adenine (A) with thymine (T). They are held together by Hydrogen bonds.

**3. The Structure of DNA**

*   **Direction:** DNA is like a one-way street because of its sugar backbone. The backbone starts at the 5' carbon and moves to the 3' carbon. 
*   **Strands:** DNA has two strands that run in opposite directions. They are "reversed complements" of each other.

**4. Replication of DNA**

*   **Copying DNA:**  Cells need to make a copy of their DNA before dividing. This is essential for biological inheritance.
*   **Unzipping:** The two strands of DNA separate.
*   **Templates:** The separated DNA strands serve as templates to make new strands with the correct pairing (A with T, C with G).
*   **DNA Polymerase:** A special helper called DNA polymerase builds the new DNA strands. Mutations (changes in DNA) can happen when new strands are being built.

**5. Genes and Chromosomes**

*   **Chromosomes:** In larger living things, DNA is organized into packages called chromosomes.
*   **Genome:** The genome is all the DNA in an organism.
*   **Complete Set:** Each cell in your body has a full set of the genome but not all cells do the same thing because genes are "expressed" differently.
*   **Genes:** A gene is a piece of DNA that holds instructions for making a protein.
*   **Gene Expression:** Gene expression is how a cell uses a gene to make a product (usually a protein). It controls when and how much of the product is made.

**6. The Central Dogma**

*   **DNA to RNA to Protein:** The central dogma is that DNA’s instructions are copied into RNA. RNA’s instructions are used to make proteins, with very few exceptions.
*   **DNA Polymerase:** Uses DNA to make more DNA copies of DNA(replication).
*   **RNA Polymerase:** Uses DNA to make RNA (transcription).
*   **Ribosome:**  A cell machine that uses RNA to make protein (translation).

**7. Transcription**

*   **Making RNA:** In transcription, a copy of a piece of DNA is made in the form of RNA.
*   **RNA Polymerase:** RNA polymerase is the machine that does the transcription. It reads the DNA strand and builds the new RNA strand.
*   **Differences from DNA:** The RNA strand is like the DNA strand except that it has a sugar called ribose instead of deoxyribose, and it has a base called uracil (U) instead of thymine (T).
*   **RNA Processing:** Proteins bind near the end of the RNA and this tells the cell where to cut off the mRNA.

**8. Translation**

*   **Making Protein:** In translation, the cell reads the RNA (mRNA) and uses it to put together a chain of amino acids, which becomes a protein.
*   **Ribosomes:** Ribosomes are the helpers that do the translation.
*   **Codons:** The mRNA is read three bases (letters) at a time. These groups of three bases are called codons.
*   **Growing Chain:** The ribosome reads the codons and adds the amino acids to the chain.
*   **Stop Codons:** When a special "stop" codon is read, the translation stops.

**9. The Genetic Code**

*   **Codon to Amino Acid:** The genetic code is how cells translate a codon into a certain amino acid.
*   **Redundancy:** The code is redundant, meaning that many different codons can code for the same amino acid, and that’s why only 20 or 21 amino acids are possible from 4^3 = 64 combinations.

**10. Proteins**

*   **Chain of Amino Acids:** Proteins are made of long chains of building blocks called amino acids.
*   **Cell Builders:** Proteins are very important in building cells.
*   **Shape and Function:** Proteins have special shapes that help them do their job. These shapes are involved in recognizing other molecules and changing how fast chemical reactions happen.
*   **Structure Levels:** Proteins have four levels of complexity:
    1.  **Primary Structure:** This is just the sequence of amino acids.
    2.  **Secondary Structure:** The sequence starts to take on shapes such as alpha-helix or beta-sheets.
    3.  **Tertiary Structure:** The chain folds into a 3-D shape.
    4.  **Quaternary Structure:** Many of these 3D shapes assemble together.

**11. Molecular Recognition**

*   **Non-Covalent Interactions:** Molecules recognize each other through weak interactions. The molecules bind to each other.

**12. Catalysis**

*   **Faster Reactions:** Catalysis makes chemical reactions happen faster using special helpers. These helpers are called catalysts, often proteins.

**13. Protein Structure: Primary to Quaternary**

*  **Levels of Structure:** The primary structure of a protein is what determines the three dimensional shape of proteins through physical interactions in the environment. The three-dimensional shape of a protein determines its functionality.

**14. Mutations**

*   **DNA Changes:** A mutation is a change in the DNA sequence.
*   **Causes:** Mutations can be caused by things like ultraviolet (UV) radiation.
*   **Types:** There are two types of mutations.
    1. **Point mutations:** These are changes to a small spot in a gene, including substitutions, insertions and deletions.
    2.  **Chromosomal Mutations:** These changes can switch around sections of DNA, either on the same chromosome or between different chromosomes.

**15. Point Mutations**

*  **Spontaneous** Some mutations happen randomly when DNA is being copied.
*   **Mutagens:** Other changes in DNA are caused by "mutagens" such as UV light, X-rays, chemicals or heat.
*   **Types of Point Mutations:** Mutations are classified in to three kinds: Silent, nonsense and missense. Silent mutations do not change the amino acid sequence. Nonsense mutations result in early stop codons and truncate the protein. Missense mutations changes the amino acid and can be conservative or non-conservative.

**16. Importance of Mutations**

*   **Disorders and Diseases:** Mutations can cause disorders, such as Sickle-Cell Anemia. In Sickle cell anemia a missense mutation leads to the replacement of glutamic acid with valine which causes blood cells to become deformed.
*  **Genetic Variation:** Mutations can also lead to genetic variation in a population and can lead to new species and adaptations to their environment.

**17. Sequence Comparison: Motivation**

*   **Similar Sequence, Similar Protein:** If two different proteins have similar sequences of amino acids, it's likely they have similar shapes and functions.
*   **Structure Similarity:** If the sequences are about 30% similar, their 3D structure is probably similar as well.

**18. Comparing Sequences**

*   **Evolution:** Over time, mutations happen that create differences between the DNA of different types of organisms.
*   **Evidence:** When we compare sequences, we look for changes that suggest they came from a common starting point and have evolved through mutations.

**19. Sequence Alignment**

*   **Putting Sequences Side-by-Side:** Sequence alignment means placing two DNA or protein sequences side-by-side to find matching letters, or to find spots where gaps need to be introduced.
*   **Spaces:** The spaces are inserted when sequences are aligned to make them have the same number of letters so that every position has a corresponding position in the other sequence.

**20. Optimal Alignment**

*   **Cost:** The goal of sequence alignment is to find the best alignment possible by having a cost for making mismatches and for creating gaps.
*   **Alphabet:** Each sequence has its own alphabet, such as A,G,C,T for DNA or a bigger set of letters representing the amino acids.
*   **Best Alignment:** We try to find the alignment that has the lowest cost, which indicates the best fit between the sequences.

**21. The Scoring Model**

*   **Score:** Assign a score to each alignment so we can choose the best one.
*  **Additive scores:** The score is computed by taking the sum of costs for matched letters and gaps.
*   **Independence:** This approach works under the assumption that mutations at different positions on a sequence happen independently of each other.
*   **Common Approach:** Most computer programs that do sequence alignments use additive scoring.

**22. Substitution Matrices**

*   **Expected Matches:** Some matches are more common than would be expected just by random chance.
*   **Probabilistic Model:** The score for matching two letters comes from how likely it is that those two letters are aligned because of how life has evolved.
*   **Score is a Ratio:** The score reflects how likely it is that two sequences are related vs being completely different.
*   **Random Model:** A simple random model would assign a certain frequency (qa) to each letter (a) where each letter is independent of the rest.
*  **Joint Probability:** The sequences would be aligned under the assumption that the sequences are generated by a match model (M) using a joint probability function.

**23. BLOSUM62 Substitution Matrix**

*   **Numbers:** BLOSUM62 is one example of a substitution matrix. It assigns a score to each possible matching of two amino acids. The scores reflect how often those pairings occur in real proteins.
*   **Higher Scores:** Higher scores mean that the amino acids are more likely to have been paired.
* **Columns** Each column in the BLOSUM62 represents the amino acids in the sequences being aligned.
* **Rows** Each row in the BLOSUM62 matrix represent how likely a particular matching is.
*  **Use** These scores are used in sequence alignment to compute the total score.

**24. Gap Penalties**

*   **Gaps are Costs:** We have to pay a penalty when we put a gap (space) in an alignment.
*  **Different Types of Gap Penalties** Different ways of counting gap penalties exist, such as:
    *   **Linear:** Each space costs the same, regardless of how long the gap is. If the gap has length 'g', the cost is -gd (d is the gap weight).
    *   **Affine:** Each gap costs a flat amount to start (-d) and a little bit more for each new space (-e). This approach models the idea that gaps are caused by insertion or deletions.
    * **Convex** Adds penalties as a log function of gap length.

**25. Global Alignment: Needleman-Wunsch Algorithm**

*  **Goal** The Needleman-Wunsch algorithm is an algorithm to find the best alignment between two sequences with some penalties for matches, mismatches and gaps.
*   **Prefix Sequences:** The algorithm finds the best alignment of the prefix sequences of the two sequences of length *i* and *j*.
*   **Empty Sequence:** A zero index *i* or *j* means that we are talking about an empty sequence, with no letters.
*   **Base Cases:** The algorithm starts from the top left and uses linear penalties for all the spaces in empty sequences (e.g.  F(i,0) = −id)
*  **Recurrence Relation** From a given location *i, j*, the algorithm takes the maximum of three values based on matches or mismatches or based on gaps on either direction (-d).

**26. Tabular Computation of Optimal Alignment**

*   **Fill the Table:** The program fills the table of values (matrix) using the recursive relationship that depends on the three surrounding cells to compute F(i,j).
*   **Calculate Each Cell:** It checks the values from the top-left, top and left cells and picks the best score and saves the score and the source of the score.
*   **Pointers:** The "pointers" that the program saves is used to retrace steps to find the best overall alignment.

**27. Time and Space Complexity**

*   **Time:** The Needleman-Wunsch algorithm checks each cell once. If *n* and *m* are the lengths of the sequences, the time is roughly proportional to *n* times *m*. So it is a O(nm) algorithm.
*   **Space:** Space is the amount of memory used. If we only want to know the best score, we can use memory equal to the length of the shortest sequence - O(m).  But if we want the entire best alignment we must save the traceback pointers, in which case we need memory that is proportional to the size of the whole table which is equal to *n* times *m* or O(nm) in space complexity.

**28. Global Alignment in Linear Space**

*   **Problem:** When we use huge sequences, we run out of memory in the computer.
*   **Solution:** We can find a way to align sequences in linear space (O(m+n)).
*   **Divide and Conquer:** The way to do this is to break the alignment problem into smaller pieces. Find the optimal path to the center and then recursively find the paths to the top and bottom.
*   **Middle Column:** We pick a middle column and find a row such that the optimal alignment passes though the (column,row) coordinates. Then split the alignment problem to the left and to the right of this middle column.

**29. Local Alignments**

*   **Part of Sequence:** Sometimes we only need to find the best match between small parts of two sequences (not the whole thing).
*   **Subsequences:** The subsequences can be parts of the sequence such as a string of amino acids.
*   **Local Suffix:** We start with finding the best suffixes in the two sequences that end at coordinates *i* and *j*. Then we iterate over all possible starting coordinates in the two sequences and compare.

**30. Local Suffix Alignments**

*   **Best Starting Point:** Local suffix alignment starts by finding the position to start a global alignment, but it will stop and consider smaller sections of the alignment if the scores go below 0.
*   **Stopping at Zero:** The start of the local alignment is found by following the best possible path back to the 0,0 position, while making sure the scores are always equal or above zero.

**31. Smith-Waterman Algorithm**

*   **Discard Prefixes:** Like local suffix alignment, Smith-Waterman is also like global alignment except that it ignores prefixes with negative scores. This allows the start of the alignment to be anywhere on the sequence.
*  **Recurrence relation** The program chooses the maximum of four options: Starting from 0, using the match score from the previous diagonal, creating a space in the vertical direction or in the horizontal direction.
*   **Best Scores:** Finally, we identify the coordinates that give the highest scores and follow the traceback pointer until it hits 0.

**32. Local vs. Global Alignment: Biological Considerations**

*   **Domains:** Proteins are made of modules called domains.
*   **Recurring Domains:** Some protein domains are repeated in many other proteins.
*   **Local is Better:** Local alignment is helpful in these situations to detect similar domains even if the proteins look different overall.

**33. Other Gap Models**

*   **Linear Not Realistic:** Linear gap models are not very good at modeling gaps, as they penalize additional gaps the same as the first.
*  **Long Gaps** Usually gaps are caused by insertions and deletions so they are often longer than just one space.
*  **General gap costs** There is a more general way to penalize gaps. However, this approach uses cubic time.

**34. Alignment with Affine Gap Costs**

*   **More "States":** We can modify the approach to affine gap costs by using extra parameters.
*  **Parameters** There are three parameters: M(i,j) is the best score if *xi* and *yj* are aligned. I(i,j) and I(i,j) are the best score when the sequences at index *i* or *j* are aligned to a gap.
*   **Transitions:** Transitions from one state to another incur costs or take on scores.

**35. Example FSA Alignment**

* **FSA** FSA is an example of a finite state automata that can use to create a state diagram.
*  **States** The diagram contains states and transitions that follow sequence alignment with affine gap costs.
* **Path** The sequence alignment corresponds to the path though different states in the diagram.
